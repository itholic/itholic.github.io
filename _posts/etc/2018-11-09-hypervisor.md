---
title: "[virtualization] 하이퍼바이저, 전가상화, 반가상화"
layout: post
tag:
- etc
- virtualization
category: etc
author: itholic
sitemap:
  changefreq: daily
  priority: 1.0
---

# 하이퍼바이저(hypervisor)

하이퍼바이저는 <a href="https://itholic.github.io/virtualization/" target="_blank">가상화</a>를 구현하기 위한 기반이 되는 기술이다.

물리머신위에 가상머신을 돌리려면, 물리머신의 자원을 적절히 가상머신에 할당해야한다.

그리고 각 가상머신에서 수행하는 명령을 해석해서 하드웨어가 올바른 동작을 할 수 있어야한다.

<br/>

윈도우와 리눅스 가상머신이 동시에 돌아가고있다고 생각해보자.

각 OS는 커널이라는 녀석이 자원관리와 명령 해석을 포함한 거의 모든것을 컨트롤하는데, 

문제는 이 커널에서 사용하는 규칙이 OS마다 모두 다르다는 것이다.

각 가상머신에서는 자원을 사용하기 위해 커널에서 여러가지 명령을 날릴텐데, 그 규칙이 모두 다르다는 것이다.

하드웨어는 어떤 장단에 맞추어야 할까?

이런 것들을 중재해주는 녀석이 바로 하이퍼바이저다.

<br/>

쉽게말해서, 

하이퍼바이저 덕분에 맥북에서 윈도우랑 리눅스를 쓸 수 있는거다.

virtual box, vmware, parallels같은 가상 머신들도 모두 하이퍼바이저라고 보면 된다.

하이퍼바이저의 종류는 크게 Type1, Type2 두 가지로 나뉜다.

![하이퍼바이저](/assets/images/2018/11/09/hypervisor.png)

- <a href="http://statkclee.github.io/raspberry-pi/raspberry-pi-virtual-env.html" target="_blank">그림 출처</a>

<br/>

## 하이퍼바이저 Type1

하이퍼바이저 Type1은 native, 혹은 bare-metal이라고도 부른다.

하이퍼바이저가 OS에 종속되지 않고 하드웨어에 직접 설치되는 구조이다.

bare-metal은 "어떤 소프트웨어도 담져있지 않은 하드웨어"를 의미한다.

<br/>

보통은 OS를 설치하면 해당 OS가 하드웨어를 컨트롤하는데,

이 방식은 하이퍼바이저 자체에서 직접 하드웨어를 제어할 수 있기때문에 상대적으로 오버헤드가 적다.

당연히 직접 관리하기때문에 리소스 관리도 유연하다.

<br/>

하지만 자유에는 항상 대가가 따른다.

하드웨어를 컨트롤할 OS가 없기 때문에 별도의 관리 기능이 필요하다.

하이퍼바이저 자체에는 별도의 관리 기능이 없기 때문이다.

때문에 bare-metal 방식에서는 하이퍼바이저 구동시 DOM0이라는 관리 머신이 같이 구동된다.

DOM0에서 얼마나 많은 일을 처리하느냐에 따라 크게 두 가지로 나누는데,

바로 전가상화와 반가상화이다.

### 전가상화

앞서 "커널에서 사용하는 규칙이 OS마다 모두 다르다" 라고 했었다.

마치 나라마다 사용하는 언어가 모두 다른 것 처럼,

같은 명령이라도 각 가상머신마다 표현하는 방식이 다르니 하드웨어는 알아먹을 방법이 없다.

이렇게 각기 다른 명령 방식을 해석해서 하드웨어에 전달하는 것이 바로 하이퍼바이저의 역할이다.


<a href="https://blog.naver.com/alice_k106/220218878967" target="_blank">alice님의 블로그</a>에 이를 매우 잘 표현한 그림이 있어서 업어(?)왔다.

![하이퍼바이저](/assets/images/2018/11/09/full.png)


윈도우, 리눅스, 맥에서 날아오는 각기 다른 명령을 하이퍼바이저가 해석해서 하드웨어에 전달하고있다.

(Supervisor라고 쓰여져있는것은 <a href="https://blog.naver.com/alice_k106/220218878967" target="_blank">원문</a>에서 실수라고 언급하고 있다)

사실 이를 더 내부적으로 들여다보면, 앞서 언급했던 DOM0이 그 역할을 하고있다.

각 가상머신은 DOM0에게 명령을 전달하고, DOM0에서 이를 해석해 하이퍼바이저에게 알려준다.

그럼 하이퍼바이저는 다시 하드웨어에게 번역된 최종 명령을 전달하는 것이다.

즉, 모든 명령에 대해 DOM0이 개입하기 때문에 성능이 반가상화에 비해 비교적 느리다.

### 반가상화

반가상화는 전가상화에서 DOM0이 수행했던 '번역'의 역할을 각 가상머신에서 처리하는 것이다.

각 나라의 언어를 번역가가 중간에서 해석하는 것이 아니라, 

명령을 던지는 사람이 직접 번역을 해서 전달한다는 것이다.

그리고 미리 번역된 명령을 DOM0을 통해서가 아닌 하이퍼바이저에게 직접 전달한다.

이 때 쓰는 명령을 Hyper-Call이라 부른다.

이 역시 <a href="https://blog.naver.com/alice_k106/220218878967" target="_blank">alice님의 블로그</a>에서 예시 그림을 업어왔다.

![하이퍼바이저](/assets/images/2018/11/09/para.png)

위에서 "더해라!" 라고 하는 부분을 Hyper-Call이라고 보면 된다.

근데, 기본적으로 커널은 이러한 Hyper-Call에 대한 지식이 없어서 이를 직접 구현해주어야 한다.

즉, 가상OS의 커널을 직접 수정해야 하는 것이다.

<br/>

중국인과 일본인에게 명령을 직접 한국말로 번역해서 보내라고 한다면, 일단 한국말을 가르쳐야 하지 않겠는가?

위 그림에서 확성기로 표현되어있는 부분이 각 OS의 커널이며, 

OS마다 서로 다른 표현(Add, ADD, add)을 "더해라!" 라는 하드웨어가 알아들을 수 있는 언어(Hyper-Call)로 번역하고있다.

이는 매우 복잡하고 어렵겠지만, 

DOM0을 경유하는 횟수가 현저히 줄어들기때문에 전가상화에비해 상대적으로 성능이 좋다.


## 하이퍼바이저 Type2

Type2는 우리가 일반적으로 사용하는 가상머신을 생각하면 된다.

하드웨어에 OS를 먼저 설치하고 그 위에 하이퍼바이저를 설치하는 구조이다.

이 때 설치되는 OS를 호스트OS라고 한다.

호스트OS가 bare-metal(하드웨어)을 알아서 관리해주기 때문에, DOM0과 같은 관리툴이 따로 필요없다.

<br/>

하지만 호스트OS위에서 하이퍼바이저가 구동되고, 

다시 그 위에 가상머신을 띄우는 방식이기때문에 오버헤드가 크다.

윈도우를 설치하고(호스트OS), 

virtual box를 설치한 다음(하이퍼바이저), 

CentOS를 구동하는것(가상머신)을 생각하면 된다.

참고로 이 때 가상머신에서 구동되는 OS를 게스트OS라고 한다.
